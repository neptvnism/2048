<!DOCTYPE html>
<html>
<head>
  <title>2048</title>
  <style>
    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #game-board {
      display: grid;
      grid-template-columns: repeat(4, 100px);
      grid-template-rows: repeat(4, 100px);
      gap: 10px;
      border: 2px solid black;
    }

    .tile {
      width: 90px;
      height: 90px;
      background-color: #ccc;
      border-radius: 5px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      font-weight: bold;
      transition: background-color 0.2s ease; /* Add a smooth transition */
    }

    .tile:hover {
      background-color: #ddd; /* Highlight tiles on hover */
    }

    .tile-2 { background-color: #eee; }
    .tile-4 { background-color: #e0e0e0; }
    .tile-8 { background-color: #c0c0c0; }
    .tile-16 { background-color: #a0a0a0; }
    .tile-32 { background-color: #808080; }
    .tile-64 { background-color: #606060; }
    .tile-128 { background-color: #404040; }
    .tile-256 { background-color: #202020; }
    .tile-512 { background-color: #202020; color: #fff; }
    .tile-1024 { background-color: #101010; color: #fff; }
    .tile-2048 { background-color: #000000; color: #fff; }

  </style>
</head>
<body>
  <div id="game-container">
    <div id="game-board"></div>
    <div id="score">Score: 0</div>
  </div>
  <script>
    const boardSize = 4;
    let board = []; // Initialize the board array
    let score = 0;

    // Create the game board elements
    const gameBoard = document.getElementById('game-board');
    for (let i = 0; i < boardSize * boardSize; i++) {
      const tile = document.createElement('div');
      tile.classList.add('tile');
      tile.id = `tile-${i}`;
      gameBoard.appendChild(tile);
      board.push(0); // Initialize board with 0 values
    }

    // Function to generate a new tile (2 or 4)
    function generateNewTile() {
      let emptyCells = [];
      for (let i = 0; i < boardSize * boardSize; i++) {
        if (board[i] === 0) {
          emptyCells.push(i);
        }
      }
      if (emptyCells.length > 0) {
        let randomIndex = Math.floor(Math.random() * emptyCells.length);
        let newTileValue = Math.random() < 0.9 ? 2 : 4; // 90% chance of 2, 10% chance of 4
        board[emptyCells[randomIndex]] = newTileValue;
        updateTileDisplay(emptyCells[randomIndex], newTileValue);
      }
    }

    // Function to update the tile display based on board values
    function updateTileDisplay(index, value) {
      const tile = document.getElementById(`tile-${index}`);
      if (value === 0) {
        tile.textContent = '';
      } else {
        tile.textContent = value;
        tile.classList.forEach(className => {
          if (className.startsWith('tile-')) {
            tile.classList.remove(className);
          }
        });
        tile.classList.add(`tile-${value}`); // Add tile class for styling
      }
    }

    // Function to handle moving tiles (example: moving up)
    function moveUp() {
      let moved = false; // Flag to indicate if any tiles moved
      for (let col = 0; col < boardSize; col++) {
        for (let row = 1; row < boardSize; row++) {
          let currentRow = row;
          let currentValue = board[row * boardSize + col];
          if (currentValue !== 0) {
            // Move up until you hit a non-zero tile or the top row
            while (currentRow > 0 && board[(currentRow - 1) * boardSize + col] === 0) {
              board[(currentRow - 1) * boardSize + col] = currentValue;
              board[currentRow * boardSize + col] = 0;
              currentRow--;
              moved = true; // A tile has moved
            }
            // Merge with the tile above if they have the same value
            if (currentRow > 0 && board[(currentRow - 1) * boardSize + col] === currentValue) {
              board[(currentRow - 1) * boardSize + col] *= 2;
              score += board[(currentRow - 1) * boardSize + col];
              board[currentRow * boardSize + col] = 0;
              currentRow--;
              moved = true; // A tile has moved
            }
          }
        }
      }
      if (moved) {
        generateNewTile(); // Generate a new tile only if tiles moved
      }
      updateBoardDisplay();
    }

    // Function to handle moving tiles down
    function moveDown() {
      let moved = false;
      for (let col = 0; col < boardSize; col++) {
        for (let row = boardSize - 2; row >= 0; row--) {
          let currentRow = row;
          let currentValue = board[row * boardSize + col];
          if (currentValue !== 0) {
            // Move down until you hit a non-zero tile or the bottom row
            while (currentRow < boardSize - 1 && board[(currentRow + 1) * boardSize + col] === 0) {
              board[(currentRow + 1) * boardSize + col] = currentValue;
              board[currentRow * boardSize + col] = 0;
              currentRow++;
              moved = true;
            }
            // Merge with the tile below if they have the same value
            if (currentRow < boardSize - 1 && board[(currentRow + 1) * boardSize + col] === currentValue) {
              board[(currentRow + 1) * boardSize + col] *= 2;
              score += board[(currentRow + 1) * boardSize + col];
              board[currentRow * boardSize + col] = 0;
              currentRow++;
              moved = true;
            }
          }
        }
      }
      if (moved) {
        generateNewTile();
      }
      updateBoardDisplay();
    }

    // Function to handle moving tiles to the left
    function moveLeft() {
      let moved = false;
      for (let row = 0; row < boardSize; row++) {
        for (let col = 1; col < boardSize; col++) {
          let currentCol = col;
          let currentValue = board[row * boardSize + col];
          if (currentValue !== 0) {
            // Move left until you hit a non-zero tile or the left edge
            while (currentCol > 0 && board[row * boardSize + (currentCol - 1)] === 0) {
              board[row * boardSize + (currentCol - 1)] = currentValue;
              board[row * boardSize + currentCol] = 0;
              currentCol--;
              moved = true;
            }
            // Merge with the tile to the left if they have the same value
            if (currentCol > 0 && board[row * boardSize + (currentCol - 1)] === currentValue) {
              board[row * boardSize + (currentCol - 1)] *= 2;
              score += board[row * boardSize + (currentCol - 1)];
              board[row * boardSize + currentCol] = 0;
              currentCol--;
              moved = true;
            }
          }
        }
      }
      if (moved) {
        generateNewTile();
      }
      updateBoardDisplay();
    }

    // Function to handle moving tiles to the right
    function moveRight() {
      let moved = false;
      for (let row = 0; row < boardSize; row++) {
        for (let col = boardSize - 2; col >= 0; col--) {
          let currentCol = col;
          let currentValue = board[row * boardSize + col];
          if (currentValue !== 0) {
            // Move right until you hit a non-zero tile or the right edge
            while (currentCol < boardSize - 1 && board[row * boardSize + (currentCol + 1)] === 0) {
              board[row * boardSize + (currentCol + 1)] = currentValue;
              board[row * boardSize + currentCol] = 0;
              currentCol++;
              moved = true;
            }
            // Merge with the tile to the right if they have the same value
            if (currentCol < boardSize - 1 && board[row * boardSize + (currentCol + 1)] === currentValue) {
              board[row * boardSize + (currentCol + 1)] *= 2;
              score += board[row * boardSize + (currentCol + 1)];
              board[row * boardSize + currentCol] = 0;
              currentCol++;
              moved = true;
            }
          }
        }
      }
      if (moved) {
        generateNewTile();
      }
      updateBoardDisplay();
    }

    // Function to update the display of all tiles
    function updateBoardDisplay() {
      for (let i = 0; i < boardSize * boardSize; i++) {
        updateTileDisplay(i, board[i]);
      }
    }

    // Function to update the score display
    function updateScore() {
      document.getElementById('score').textContent = 'Score: ' + score;
    }

    // Initialize the game
    generateNewTile();
    generateNewTile();
    updateBoardDisplay();

    // Add event listeners for keyboard input
    document.addEventListener('keydown', (event) => {
      switch (event.key) {
        case 'ArrowUp':
          moveUp();
          break;
        case 'ArrowDown':
          moveDown();
          break;
        case 'ArrowLeft':
          moveLeft();
          break;
        case 'ArrowRight':
          moveRight();
          break;
      }
    });
  </script>
</body>
</html>
